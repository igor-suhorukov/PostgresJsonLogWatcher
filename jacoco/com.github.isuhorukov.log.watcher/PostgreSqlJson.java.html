<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PostgreSqlJson.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PostgresLogParser</a> &gt; <a href="index.source.html" class="el_package">com.github.isuhorukov.log.watcher</a> &gt; <span class="el_source">PostgreSqlJson.java</span></div><h1>PostgreSqlJson.java</h1><pre class="source lang-java linenums">package com.github.isuhorukov.log.watcher;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.event.Level;
import org.slf4j.spi.LoggingEventBuilder;
import picocli.CommandLine;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;

/**
 * The {@code PostgreSqlJson} class is a command-line tool for reading
 * PostgreSQL DBMS logs in JSON format and sending them to an OpenTelemetry collector.
 * It can optionally use a {@link LogEnricher} to add additional data to the logs.
 */
@CommandLine.Command(mixinStandardHelpOptions = true, versionProvider = VersionProvider.class,
        name = &quot;postgres_log_parser&quot;,
        header = &quot;This program reads PostgreSQL DBMS logs in JSON format and sends them to OpenTelemetry collector&quot;)
@Setter
<span class="fc" id="L34">public class PostgreSqlJson implements Callable&lt;Integer&gt;, Closeable {</span>

    public static final String DURATION = &quot;duration: &quot;;
    public static final String MS = &quot; ms&quot;;
    public static final String PLAN = &quot;plan:\n&quot;;
    public static final String QUERY_ID = &quot;query_id&quot;;
    public static final String JSON_SUFFIX = &quot;.json&quot;;

<span class="fc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(PostgreSqlJson.class);</span>
<span class="fc" id="L43">    private static final Logger cliLogger = LoggerFactory.getLogger(&quot;cli&quot;);</span>

<span class="fc" id="L45">    private static final ObjectMapper mapper = new ObjectMapper();</span>

<span class="fc" id="L47">    final Map&lt;String, Long&gt; position = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L49">    LogEnricher logEnricher = new EnrichmentOff();</span>

    @CommandLine.Parameters(index = &quot;0&quot;, description = &quot;Path to PostgreSQL log directory in JSON format&quot;)
    String watchDir;
    @CommandLine.Option(names = {&quot;-i&quot;, &quot;--save_interval&quot;},  defaultValue = &quot;10&quot;,
            description = &quot;Interval of saving (in second) of the current read position in the log files. &quot; +
                    &quot;The value must be within a range from 1 till 1000 second&quot;)
    long saveInterval;
    @CommandLine.Option(names = {&quot;-H&quot;, &quot;--host&quot;}, description = &quot;The host name of the PostgreSQL server&quot;)
    String posgreSqlHost;
    @CommandLine.Option(names = {&quot;-p&quot;, &quot;--port&quot;}, defaultValue = &quot;5432&quot;, description = &quot;The port number the PostgreSQL server is listening on&quot;)
    int posgreSqlPort;
    @CommandLine.Option(names = {&quot;-d&quot;, &quot;--database&quot;}, defaultValue = &quot;postgres&quot;, description = &quot;The database name&quot;)
    String posgreSqlDatabase;
    @CommandLine.Option(names = {&quot;-u&quot;, &quot;--user&quot;}, defaultValue = &quot;postgres&quot;,
            description = &quot;The database user on whose behalf the connection is being made&quot;)
    String posgreSqlUserName;

<span class="fc" id="L67">    @CommandLine.Option(names = &quot;--password&quot;, arity = &quot;0..1&quot;, interactive = true)</span>
<span class="fc" id="L68">    String posgreSqlPassword = System.getenv(&quot;PGPASSWORD&quot;);</span>

    @CommandLine.Option(names = {&quot;-c&quot;, &quot;--max_cache_size&quot;},  defaultValue = &quot;50000&quot;,
            description = &quot;Database query cache size&quot;)
    int maximumQueryCacheSize;
    @CommandLine.Option(names = {&quot;-lp&quot;, &quot;--log_pos_file&quot;}, defaultValue = &quot;.current_log_position&quot;,
            description = &quot;Path to file to save current processed position in log files. &quot; +
                    &quot;Required write capability for this program&quot;)
    String currentLogPositionFile;
    @Getter
    private WatchService fsWatchService;

<span class="pc" id="L80">    @SneakyThrows</span>
    public static void main(String[] args) {
<span class="fc" id="L82">        try (PostgreSqlJson postgreSqlJson = new PostgreSqlJson()){</span>
<span class="fc" id="L83">            int exitCode = new CommandLine(postgreSqlJson).execute(args);</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if(!Boolean.getBoolean(&quot;skipProcessExit&quot;)){</span>
<span class="nc" id="L85">                System.exit(exitCode);</span>
            }
        }
<span class="fc" id="L88">    }</span>

    @Override
    public Integer call() throws Exception {
<span class="fc" id="L92">        return watchPostgreSqlLogs();</span>
    }

    /**
     * Monitors the PostgreSQL log directory for changes and processes the logs.
     * &lt;p&gt;
     * This method sets up a WatchService to continuously monitor the specified
     * directory for new or modified log files in JSON format. When such a file
     * is detected, it is processed to extract relevant log information.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The method also makes use of a log enricher (if configured) to enhance the log data
     * with additional information.
     * &lt;/p&gt;
     *
     * @throws IOException if an I/O error occurs initializing the watcher or processing the logs.
     * @throws InterruptedException if the watch service is interrupted while waiting for events.
     */
    public int watchPostgreSqlLogs() throws IOException, InterruptedException {
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">        if(watchDir==null || watchDir.trim().isEmpty()){</span>
<span class="fc" id="L113">            cliLogger.error(&quot;Path to PostgreSQL log directory expected&quot;);</span>
<span class="fc" id="L114">            return 1;</span>
        }
<span class="fc" id="L116">        File sourceDirectory = new File(watchDir);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if(!sourceDirectory.exists()) {</span>
<span class="fc" id="L118">            cliLogger.error(&quot;PostgreSQL directory '{}' with JSON logs not exist&quot;, watchDir);</span>
<span class="fc" id="L119">            return 1;</span>
        }
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if(!sourceDirectory.isDirectory()){</span>
<span class="fc" id="L122">            cliLogger.error(&quot;Path '{}' is not directory&quot;, watchDir);</span>
<span class="fc" id="L123">            return 1;</span>
        }
<span class="fc bfc" id="L125" title="All 4 branches covered.">        if(saveInterval&lt;=0 || saveInterval&gt;1000){</span>
<span class="fc" id="L126">            cliLogger.error(&quot;saveInterval must be between 1 and 1000 sec. Actual value {}&quot;, saveInterval);</span>
<span class="fc" id="L127">            return 1;</span>
        }
<span class="fc" id="L129">        initLogEnricher();</span>
<span class="fc" id="L130">        positionFileTasks();</span>
<span class="fc" id="L131">        initialLogImport(sourceDirectory);</span>
<span class="fc" id="L132">        Path dirToWatch = Paths.get(watchDir);</span>
<span class="fc" id="L133">        fsWatchService = getWatchService();</span>
<span class="fc" id="L134">        try (WatchService watchService = fsWatchService) {</span>
<span class="fc" id="L135">            registerWatchEvent(dirToWatch, watchService);</span>
            WatchKey key;
<span class="fc bfc" id="L137" title="All 2 branches covered.">            while ((key = watchService.take()) != null) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                for (WatchEvent&lt;?&gt; event : key.pollEvents()) {</span>
<span class="fc" id="L139">                    String fileName = event.context().toString();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                    if(!fileName.endsWith(JSON_SUFFIX)){</span>
<span class="fc" id="L141">                        continue;</span>
                    }
<span class="fc" id="L143">                    readJsonLog(new File(watchDir, fileName));</span>
<span class="fc" id="L144">                }</span>
<span class="fc" id="L145">                key.reset();</span>
            }
        }
<span class="fc" id="L148">        return 0;</span>
    }

    /**
     * Initializes the log enricher for PostgreSQL logs.
     * &lt;p&gt;
     * This method creates an instance of {@link LogEnricherPostgreSql} with the specified
     * PostgreSQL host, port, database, username, password, and query cache size.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the PostgreSQL host is not set or is empty, the method does not initialize the
     * log enricher, logs an error and instantiate EnrichmentOff instead of LogEnricherPostgreSql.
     * &lt;/p&gt;
     */
    void initLogEnricher() {
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">        if(posgreSqlHost !=null &amp;&amp; !posgreSqlHost.isEmpty()){</span>
            try {
<span class="fc" id="L165">                logEnricher = new LogEnricherPostgreSql(posgreSqlHost, posgreSqlPort, posgreSqlDatabase, posgreSqlUserName, posgreSqlPassword, maximumQueryCacheSize);</span>
<span class="fc" id="L166">            } catch (Exception e) {</span>
<span class="fc" id="L167">                cliLogger.error(&quot;Failed to use log enricher {} for postgres, so I work in mode without log enrichment&quot;,</span>
<span class="fc" id="L168">                        LogEnricherPostgreSql.class.getSimpleName(), e);</span>
<span class="fc" id="L169">                logEnricher = new EnrichmentOff();</span>
<span class="fc" id="L170">            }</span>
            try {
<span class="fc" id="L172">                logEnricher.getStatement(&quot;0&quot;);</span>
<span class="fc" id="L173">                cliLogger.info(&quot;{} up and running&quot;, LogEnricherPostgreSql.class.getSimpleName());</span>
<span class="fc" id="L174">            } catch (Exception e) {</span>
<span class="fc" id="L175">                cliLogger.error(&quot;Make sure the extension is available in the database: CREATE EXTENSION pg_stat_statements;\n&quot; +</span>
                        &quot;https://www.postgresql.org/docs/current/pgstatstatements.html&quot;, e);
<span class="fc" id="L177">                logEnricher = new EnrichmentOff();</span>
<span class="fc" id="L178">            }</span>

        } else {
<span class="fc" id="L181">            logEnricher =  new EnrichmentOff();</span>
        }
<span class="fc" id="L183">    }</span>

    protected void registerWatchEvent(Path dirToWatch, WatchService watchService) throws IOException {
<span class="fc" id="L186">        dirToWatch.register(watchService, ENTRY_CREATE, ENTRY_MODIFY);</span>
<span class="fc" id="L187">    }</span>

    protected WatchService getWatchService() throws IOException {
<span class="fc" id="L190">        return FileSystems.getDefault().newWatchService();</span>
    }

    /**
     * Performs the initial import of PostgreSQL JSON log files from the specified directory.
     * &lt;p&gt;
     * This method reads all JSON log files in the given directory, sorts them by name,
     * and processes each file by calling the {@link #readJsonLog(File)} method.
     * &lt;/p&gt;
     *
     * @param sourceDirectory the directory containing the PostgreSQL JSON log files to be imported.
     * @throws IOException if an I/O error occurs while reading the log files.
     */
    protected void initialLogImport(File sourceDirectory) throws IOException {
<span class="fc" id="L204">        File[] jsonLogs = sourceDirectory.listFiles(pathname -&gt; pathname.getName().endsWith(JSON_SUFFIX));</span>

<span class="pc bpc" id="L206" title="2 of 4 branches missed.">        if(jsonLogs!=null &amp;&amp; jsonLogs.length&gt;0){</span>
<span class="fc" id="L207">            Arrays.sort(jsonLogs, Comparator.comparing(File::getName));</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for(File jsonLog: jsonLogs){</span>
<span class="fc" id="L209">                readJsonLog(jsonLog);</span>
            }
        }
<span class="fc" id="L212">    }</span>

    /**
     * Parses a single line of PostgreSQL JSON log and logs it according to its severity level.
     * &lt;p&gt;
     * This method reads a log line in JSON format, determines the severity level of the log message,
     * and logs the message using the appropriate logging level. If the corresponding logging level
     * (TRACE, DEBUG, INFO, WARN, ERROR) is not enabled, the method will return immediately without
     * further processing the log line.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The method uses the {@code error_severity} field from the JSON log to determine the logging level
     * and creates a logging event with additional key-value pairs extracted from the JSON log.
     * It also handles various log message formats, adjusting or adding specific log attributes such as
     * duration, plan, parse, and bind if they are present in the message.
     * &lt;/p&gt;
     * @param line the log line in JSON format to be parsed.
     * @param logName the name of the log file from which the line was read.
<span class="pc" id="L230">     */    @SneakyThrows</span>
    void parseLogLine(String line, String logName){
<span class="fc" id="L232">        JsonNode jsonNode = mapper.readTree(line);</span>
<span class="fc" id="L233">        Level severity = getSeverity(jsonNode.at(&quot;/error_severity&quot;).asText());</span>
<span class="pc bpc" id="L234" title="1 of 6 branches missed.">        switch (severity){</span>
            case TRACE:
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">                if(!logger.isTraceEnabled()) return;</span>
                break;
            case DEBUG:
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">                if(!logger.isDebugEnabled()) return;</span>
                break;
            case INFO:
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                if(!logger.isInfoEnabled()) return;</span>
                break;
            case WARN:
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                if(!logger.isWarnEnabled()) return;</span>
                break;
            case ERROR:
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                if(!logger.isErrorEnabled()) return;</span>
                break;
        }

<span class="fc" id="L252">        Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = jsonNode.fields();</span>

<span class="fc" id="L254">        String message = jsonNode.at(&quot;/message&quot;).asText();</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">        if(logEnricher.enricherApplicationName()!=null &amp;&amp; message.contains(logEnricher.enricherApplicationName())){</span>
<span class="nc" id="L256">            return;</span>
        }

<span class="fc" id="L259">        LoggingEventBuilder loggingEventBuilder = logger.atLevel(severity);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if(message.startsWith(DURATION)){</span>
<span class="fc" id="L261">            int msEndIndex = message.indexOf(MS);</span>
<span class="fc" id="L262">            double duration = Double.parseDouble(message.substring(DURATION.length(), msEndIndex));</span>
<span class="fc" id="L263">            loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;duration&quot;, duration);</span>
<span class="fc" id="L264">            int planIdx = message.indexOf(PLAN);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if(planIdx!=-1){</span>
<span class="fc" id="L266">                String plan = message.substring(planIdx + PLAN.length());</span>
<span class="fc" id="L267">                loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;plan&quot;, plan);</span>
<span class="fc" id="L268">            } else</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if(message.indexOf(&quot; parse &quot;,msEndIndex+2)&gt;-1){</span>
<span class="fc" id="L270">                loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;parse&quot;, true);</span>
            } else
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if(message.indexOf(&quot; bind &quot;,msEndIndex+2)&gt;-1){</span>
<span class="fc" id="L273">                loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;bind&quot;, true);</span>
            }
<span class="fc" id="L275">            loggingEventBuilder = loggingEventBuilder.setMessage(&quot;&quot;);</span>
<span class="fc" id="L276">        } else {</span>
<span class="fc" id="L277">            loggingEventBuilder = loggingEventBuilder.setMessage(message);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if(message.startsWith(&quot;statement: &quot;)){</span>
<span class="fc" id="L279">                loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;statement&quot;, true);</span>
            } else
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if(message.startsWith(&quot;execute&quot;)){</span>
<span class="fc" id="L282">                loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;execute&quot;, true);</span>
            }
        }
<span class="fc bfc" id="L285" title="All 2 branches covered.">        while (fields.hasNext()) {</span>
<span class="fc" id="L286">            Map.Entry&lt;String, JsonNode&gt; entry = fields.next();</span>
<span class="fc" id="L287">            String key = entry.getKey();</span>
<span class="fc" id="L288">            String value = entry.getValue().asText();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if(&quot;message&quot;.equals(key) ||</span>
<span class="fc bfc" id="L290" title="All 4 branches covered.">                    (QUERY_ID.equals(key) &amp;&amp; &quot;0&quot;.equals(value)) //skip empty query_id</span>
            ){
<span class="fc" id="L292">                continue;</span>
            }
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">            if(&quot;application_name&quot;.equals(key) &amp;&amp; value.equals(logEnricher.enricherApplicationName())){</span>
<span class="nc" id="L295">                return; //skip enricher log record by clientName</span>
            }
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if(QUERY_ID.equals(key)){</span>
<span class="fc" id="L298">                String queryId = value;</span>
<span class="fc" id="L299">                String statement = logEnricher.getStatement(queryId);</span>
<span class="pc bpc" id="L300" title="1 of 4 branches missed.">                if(statement!=null &amp;&amp; !statement.isEmpty()){</span>
<span class="fc" id="L301">                    loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;statement_text&quot;, statement);</span>
                }
            }
<span class="fc" id="L304">            JsonNode entryValue = entry.getValue();</span>
<span class="fc" id="L305">            loggingEventBuilder = loggingEventBuilder.addKeyValue(key, getValue(entryValue));</span>
<span class="fc" id="L306">        }</span>
<span class="fc" id="L307">        loggingEventBuilder = loggingEventBuilder.addKeyValue(&quot;fileName&quot;, logName);</span>
<span class="fc" id="L308">        loggingEventBuilder.log();</span>
<span class="fc" id="L309">    }</span>

    private static Object getValue(JsonNode entryValue) {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        switch (entryValue.getNodeType()){</span>
            case NUMBER:
<span class="pc bpc" id="L314" title="1 of 3 branches missed.">                switch (entryValue.numberType()){</span>
                    case INT:
<span class="fc" id="L316">                        return entryValue.asInt();</span>
                    case LONG:
<span class="fc" id="L318">                        return entryValue.asLong();</span>
                }
            case STRING:
            default:
<span class="fc" id="L322">                return entryValue.asText();</span>
        }
    }

    private static Level getSeverity(String severity) {
        //https://www.postgresql.org/docs/current/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS
<span class="fc bfc" id="L328" title="All 5 branches covered.">        switch (severity){</span>
            case &quot;DEBUG&quot;:
            case &quot;DEBUG5&quot;:
            case &quot;DEBUG4&quot;:
            case &quot;DEBUG3&quot;:
            case &quot;DEBUG2&quot;:
<span class="fc" id="L334">            case &quot;DEBUG1&quot;: return Level.DEBUG;</span>
            case &quot;LOG&quot;:
            case &quot;INFO&quot;:
<span class="fc" id="L337">            case &quot;NOTICE&quot;: return Level.INFO;</span>
<span class="fc" id="L338">            case &quot;WARNING&quot;: return Level.WARN;</span>
            case &quot;ERROR&quot;:
            case &quot;FATAL&quot;:
<span class="fc" id="L341">            case &quot;PANIC&quot;: return Level.ERROR;</span>
            default:
<span class="fc" id="L343">                return Level.TRACE;</span>
        }
    }

    /**
     * Manages the tasks related to handling positional information for PostgreSQL log files.
     * &lt;p&gt;
     * This method processes and updates the positional information of log files to ensure that
     * logs are correctly read and parsed from the last known position. It handles the initialization,
     * periodic updates, and finalization of positions for different log files. The method ensures
     * that log parsing can resume correctly after restarts or interruptions by accurately maintaining
     * and updating the position information.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The method typically involves the following tasks:
     * &lt;/p&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;Initializing the position map for new log files.&lt;/li&gt;
     *   &lt;li&gt;Updating the position as logs are read and processed.&lt;/li&gt;
     *   &lt;li&gt;Saving the current position to persistent storage.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * This method is crucial for log processing scenarios where it's important to not miss any log
     * entries and to avoid reprocessing already handled logs.
     * &lt;/p&gt;
     *
     * @throws IOException if an I/O error occurs while managing the log file positions.
     */
    protected Thread positionFileTasks() throws IOException {
<span class="fc" id="L372">        File currentPositionFile = new File(currentLogPositionFile);</span>
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">        if(currentPositionFile.exists() &amp;&amp; currentPositionFile.length()&gt;0) {</span>
<span class="fc" id="L374">            position.putAll(mapper.readValue(currentPositionFile,</span>
<span class="fc" id="L375">                    new TypeReference&lt;ConcurrentHashMap&lt;String, Long&gt;&gt;() {}));</span>
        }
<span class="fc" id="L377">        new Timer(&quot;LogPositionSaver&quot;, true).schedule(new TimerTask() {</span>
            @Override
            public void run() {
<span class="fc" id="L380">                saveLogFilesPosition();</span>
<span class="fc" id="L381">            }</span>
<span class="fc" id="L382">        }, TimeUnit.SECONDS.toMillis(saveInterval), TimeUnit.SECONDS.toMillis(saveInterval));</span>
<span class="fc" id="L383">        Thread savePostitionShutdownHook = new Thread(this::saveLogFilesPosition);</span>
<span class="fc" id="L384">        Runtime.getRuntime().addShutdownHook(savePostitionShutdownHook);</span>
<span class="fc" id="L385">        return savePostitionShutdownHook;</span>
    }

    /**
     * Saves the current read positions of PostgreSQL log files.
     * &lt;p&gt;
     * This method writes the current positions of log files to a specified file, ensuring accurate
     * resume points after restarts or interruptions. It ensures atomicity and consistency to prevent
     * data loss.
     * &lt;/p&gt;
     */
    protected synchronized void saveLogFilesPosition() {
        try {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if(position.isEmpty()){</span>
<span class="nc" id="L399">                return;</span>
            }
<span class="fc" id="L401">            try (FileOutputStream currentPostitionFile = new FileOutputStream(currentLogPositionFile)){</span>
<span class="fc" id="L402">                mapper.writeValue(currentPostitionFile,new TreeMap&lt;&gt;(position));</span>
            }
<span class="fc" id="L404">        } catch (Exception e) {</span>
<span class="fc" id="L405">            cliLogger.error(&quot;Unable to save current log position&quot;, e);</span>
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">    }</span>

    /**
     * Reads a JSON log file and processes each line.
     * This method reads through the specified JSON log file starting from the last saved position,
     * parses each line, and processes it according to the log's severity level. It updates the
     * read position after processing each log entry to ensure accurate resumption.
     *
     * @param jsonLog the JSON log file to read
     * @throws IOException if an error occurs while reading the log file
     */
    void readJsonLog(File jsonLog) throws IOException {
<span class="fc" id="L419">        String jsonLogName = jsonLog.getName();</span>
<span class="fc" id="L420">        long from = position.computeIfAbsent(jsonLogName, name -&gt; 0L);</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if(jsonLog.length() ==0){</span>
<span class="nc" id="L422">            return;</span>
        }
<span class="pc bpc" id="L424" title="2 of 4 branches missed.">        if(jsonLog.length()==0 || jsonLog.length()&lt;=position.computeIfAbsent(jsonLogName, name -&gt; 0L)){</span>
<span class="nc" id="L425">            return;</span>
        }
<span class="fc" id="L427">        try (RandomAccessFile randomAccessJson = new RandomAccessFile(jsonLog, &quot;r&quot;)) {</span>
<span class="fc" id="L428">            randomAccessJson.seek(from);</span>
            String line;
<span class="fc bfc" id="L430" title="All 2 branches covered.">            while ((line = randomAccessJson.readLine())!= null) {</span>
<span class="fc" id="L431">                parseLogLine(line, jsonLogName);</span>
            }
        }
<span class="fc" id="L434">        position.put(jsonLogName, jsonLog.length());</span>
<span class="fc" id="L435">    }</span>

    @Override
    public void close() throws IOException {
<span class="fc" id="L439">        logEnricher.close();</span>
<span class="fc" id="L440">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>